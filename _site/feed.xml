<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zengxi0302&#39;s  blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://zengxi0302.github.io/</link>
    <atom:link href="http://zengxi0302.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 20 Aug 2015 00:33:11 +0800</pubDate>
    <lastBuildDate>Thu, 20 Aug 2015 00:33:11 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>linux常用定位方法-iostat</title>
        <description>&lt;h2 id=&quot;iostatio&quot;&gt;iostat分析io性能&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;对于I/O-bond类型的进程(如写话单、读写数据库等与磁盘紧密相关的进程)，我们经常用iostat工具查看进程IO请求下发的数量、系统处理IO请求的耗时，进而分析进程与操作系统的交互过程中IO方面是否存在瓶颈。
下面通过iostat命令的使用实例，说明使用iostat查看IO请求下发情况、系统IO处理能力的方法，以及命令执行结果中各字段的含义。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;dd if=/dev/zero of=test.img bs=1M count=1024 &amp;amp; //写一个1G大小的文件，块大小1M

Device:  rrqm/s   wrqm/s    r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda       0.00     4.00    0.00  106.00     0.00    44.73   864.30    55.80  678.11    0.00  678.11   9.43 100.00
sda       0.00     2.00    4.00   90.00     0.02    41.98   914.98    46.67  522.81  129.00  540.31  10.64 100.00
sda       0.00     6.00    0.00   96.00     0.00    44.95   959.00    45.71  317.92    0.00  317.92  10.42 100.00
sda       0.00   117.00    1.00   86.00     0.00    39.25   924.14    32.83  560.55  188.00  564.88  11.49 100.00
sda       0.00     3.00    0.00   97.00     0.00    44.55   940.54    53.12  339.96    0.00  339.96  10.31 100.00&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;各个字段含义&lt;/h2&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rrqm/s  : 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并
		  (即1s内两次读同一块算一次，统计的是io覆盖区块程度)
wrqm/s  : 每秒对该设备的写请求被合并次数
r/s     : 每秒完成的读次数
w/s     : 每秒完成的写次数
rsec/s  : 每秒读数据量(数据块为单位，0.5kB)
wsec/s  : 每秒写数据量(数据块为单位，0.5kB)
avgrq-sz: 平均每次IO操作的数据量(扇区数为单位)
avgqu-sz: 平均等待处理的IO请求队列长度（单位个IO请求）
await   : 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)
svctm   : 平均每次IO请求的处理时间(毫秒为单位)
%util   : 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;iostat&quot;&gt;iostat数据解读&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;因为以1M的块大小写文件，且没有指定iflag=direct，因次这个写任务会走buffer IO。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从wrqm/s项非零看，IO调度层存在合并的IO，也说明的确是buffer IO。&lt;/li&gt;
  &lt;li&gt;从w/s项可知该本地硬盘的iops写能力只能平均达100iops/s，说明磁盘本身的转速不高。&lt;/li&gt;
  &lt;li&gt;从wMB/s项显示吞吐量最高达45MB/s左右，一样不高。&lt;/li&gt;
  &lt;li&gt;从avgqu-sz看平均队列深度为50左右，而svctm为10ms，所以await值会比较高，400~500的均值正常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综合评价，该本地磁盘的IO性能偏低。&lt;/p&gt;

</description>
        <pubDate>Thu, 20 Aug 2015 08:30:00 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/08/20/iostat.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/08/20/iostat.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>crash手工解析栈方法</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;引言&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;在处理主机重启的问题时，我们关心的入参或运行时变量值大多可以通过寄存器记录的数据获取。
但是，有时候有些我们关心的数据不一定就直接存在在寄存器，又或栈顶被破坏了，bt无法解析堆栈。
此时，我们就需要尝试通过手动解析栈的方式获得我们感兴趣的数据。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;一个例子&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;下面，以echo c &amp;gt; /proc/sysrq-trigger触发crash的例子说明如何手工解栈。&lt;/p&gt;

&lt;p&gt;bt解析的调用栈如下。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;crash&amp;gt; bt
PID: 10109  TASK: ffff8801b80ee440  CPU: 0   COMMAND: &amp;quot;bash&amp;quot;
 #0 [ffff8801b283db30] crash_kexec at ffffffff8008d88a
 #1 [ffff8801b283dc00] oops_end at ffffffff8040edc8
 #2 [ffff8801b283dc20] __bad_area_nosemaphore at ffffffff8001e67d
 #3 [ffff8801b283dce0] do_page_fault at ffffffff80411b94
 #4 [ffff8801b283dde0] page_fault at ffffffff8040e0d8
    [exception RIP: sysrq_handle_crash+13]
    RIP: ffffffff802c43fd  RSP: ffff8801b283de90  RFLAGS: 00010096
    RAX: 0000000000000010  RBX: ffffffff807188c0  RCX: 0000000000000010
    RDX: 0000000000000000  RSI: 00000000cc95cc95  RDI: 0000000000000063
    RBP: 0000000000000063   R8: ffffffff808e779d   R9: 0000000000000056
    R10: 0000000000000056  R11: 0000000000000046  R12: 0000000000000000
    R13: 0000000000000003  R14: 0000000000000000  R15: 0000000000000002
    ORIG_RAX: ffffffffffffffff  CS: 10000e030  SS: e02b
 #5 [ffff8801b283de90] __handle_sysrq at ffffffff802c4b5d
 #6 [ffff8801b283dec0] write_sysrq_trigger at ffffffff802c4be8
 #7 [ffff8801b283ded0] proc_reg_write at ffffffff8018e882
 #8 [ffff8801b283df10] vfs_write at ffffffff8012d4ce
 #9 [ffff8801b283df40] sys_write at ffffffff8012d643
#10 [ffff8801b283df80] system_call_fastpath at ffffffff80415cc3
    RIP: 00007fe37bea9be0  RSP: 00007ffd65fc3958  RFLAGS: 00000246
    RAX: 0000000000000001  RBX: ffffffff80415cc3  RCX: 0000000000000001
    RDX: 0000000000000002  RSI: 00007fe37c646000  RDI: 0000000000000001
    RBP: 0000000000000002   R8: 00007fe37c7ad700   R9: 0000000000000020
    R10: 00007fe37c150e30  R11: 0000000000000246  R12: 00007fe37c14f7c0
    R13: 00007fe37c646000  R14: 0000000000000002  R15: 00000000006b4430
    ORIG_RAX: 0000000000000001  CS: e033  SS: e02b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-2&quot;&gt;问题&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;假设，我们并不知道这是通过echo c &amp;gt; /proc/sysrq-trigger造成的crash。单纯的从堆栈来看，只能看出来是在调sys_write写一个文件时触发的主机重启。那么，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题是：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写哪一个文件时触发的主机重启？
显然sysrq_handle_crash显示的寄存器内容并没有提供这样的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;思路是：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;vfs_write肯定有一个打开要写的file对象，而file里的dentry字段会保存有文件名。虽然调用栈#8 vfs_write并提供寄存器信息，但是栈上可能会有我们需要的file对象地址，因此需要手工解析栈。&lt;/p&gt;

&lt;h1 id=&quot;step1-&quot;&gt;Step1 打出栈内容&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;利用bt -f打印出每个桢的栈内容，截取其中部分。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#7 [ffff8801b283ded0] proc_reg_write at ffffffff8018e882&lt;/span&gt;
    ffff8801b283ded8: 00007fe37c646000 0000000000000002
    ffff8801b283dee8: ffff8801b7a5c5c0 ffff8801b283df50
    ffff8801b283def8: 00007fe37c646000 00007ffd65fc3a20
    ffff8801b283df08: &lt;span class=&quot;m&quot;&gt;0000000000000000&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;ffffffff8012d4ce &amp;lt;- vfs_write里调用proc_reg_write返回&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;后要执行的下一条指令。因为调用回来要知道从哪里继续执行，所以会压栈&amp;quot;&lt;/span&gt;
 &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ffff8801b283df10&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; vfs_write at ffffffff8012d4ce
    ffff8801b283df18: ffff8801b518a080 ffff8801b7a5c5c0
    ffff8801b283df28: fffffffffffffff7 0000000000000002
    ffff8801b283df38: 00007fe37c646000 &lt;span class=&quot;s2&quot;&gt;&amp;quot;ffffffff8012d643 &amp;lt;- 同上，这是sys_write调用vfs_write&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;返回后将要执行的下一条指令。&amp;quot;&lt;/span&gt;
 &lt;span class=&quot;m&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ffff8801b283df40&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; sys_write at ffffffff8012d643
    ffff8801b283df48: 00000000006b4430 0000000000000000
    ffff8801b283df58: 00000000006b4430 0000000000000002
    ffff8801b283df68: 00007fe37c646000 00007fe37c14f7c0
    ffff8801b283df78: &lt;span class=&quot;m&quot;&gt;0000000000000002&lt;/span&gt; ffffffff80415cc3
&lt;span class=&quot;c&quot;&gt;#10 [ffff8801b283df80] system_call_fastpath at ffffffff80415cc3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;vfs_write函数从进入，到执行到vfs_write再往下调用的最后一条指令&lt;em style=&quot;color:red&quot;&gt;ffffffff8012d4ce&lt;/em&gt;，栈中内容分别是&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#8 [ffff8801b283df10] vfs_write at ffffffff8012d4ce
    ffff8801b283df18: ffff8801b518a080 ffff8801b7a5c5c0
    ffff8801b283df28: fffffffffffffff7 0000000000000002
    ffff8801b283df38: 00007fe37c646000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;step2-&quot;&gt;Step2 反汇编解析&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;sys_write调用进入vfs_write时，栈顶指针&lt;em style=&quot;color:red&quot;&gt;rsp = ffff8801b283df40&lt;/em&gt;。再结合vfs_write的反汇编，可以反推栈上的数据来源是什么。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;0xffffffff8012d400 &amp;lt;vfs_write&amp;gt;: 	   sub    &lt;span class=&quot;nv&quot;&gt;$0x28&lt;/span&gt;%rsp	       
&lt;span class=&quot;s2&quot;&gt;&amp;quot;rsp=rsp-0x28=ffff8801b283df40-0x28=0xffff8801b283df18，开辟5个8字节的栈空间&amp;quot;&lt;/span&gt;
0xffffffff8012d404 &amp;lt;vfs_write+4&amp;gt;:       mov    %rbx0x8&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;	
&lt;span class=&quot;s2&quot;&gt;&amp;quot;rsp+0x8位置写入rbx的内容 ffff8801b7a5c5c0&amp;quot;&lt;/span&gt;
0xffffffff8012d409 &amp;lt;vfs_write+9&amp;gt;:       mov    %rbp0x10&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;	
&lt;span class=&quot;s2&quot;&gt;&amp;quot;rsp+0x10位置写入rbp的内容 fffffffffffffff7&amp;quot;&lt;/span&gt;
0xffffffff8012d40e &amp;lt;vfs_write+14&amp;gt;:      mov    &lt;span class=&quot;nv&quot;&gt;$0xfffffffffffffff7&lt;/span&gt;%rbx
0xffffffff8012d415 &amp;lt;vfs_write+21&amp;gt;:      mov    %r120x18&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;	
&lt;span class=&quot;s2&quot;&gt;&amp;quot;rsp+0x18位置写入r12的内容 0000000000000002&amp;quot;&lt;/span&gt;
0xffffffff8012d41a &amp;lt;vfs_write+26&amp;gt;:      mov    %r130x20&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;	
&lt;span class=&quot;s2&quot;&gt;&amp;quot; rsp+0x20位置写入r13内容00007fe37c646000 buf -- 这是一个虚拟地址&amp;quot;&lt;/span&gt;
0xffffffff8012d41f &amp;lt;vfs_write+31&amp;gt;:      mov    %rdi%rbp
0xffffffff8012d422 &amp;lt;vfs_write+34&amp;gt;:      testb  &lt;span class=&quot;nv&quot;&gt;$0x20x44&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rdi&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;&amp;quot;既然知道了栈上数据来源分别来自rbx rbp r12 r13的值，但还不知道它们的含义。&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt; 因此，需要往上追溯sys_write里对这几个寄存器的操作。去了解这几个寄存器内容的含义。&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt; 继续反汇编sys_write分析。&amp;quot;&lt;/span&gt;
0xffffffff8012d5f0 &amp;lt;sys_write&amp;gt;: 	   sub    &lt;span class=&quot;nv&quot;&gt;$0x38&lt;/span&gt;%rsp
0xffffffff8012d5f4 &amp;lt;sys_write+4&amp;gt;:       mov    %r130x30&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0xffffffff8012d5f9 &amp;lt;sys_write+9&amp;gt;:       mov    %rsi%r13
0xffffffff8012d5fc &amp;lt;sys_write+12&amp;gt;:      lea    0x14&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;%rsi
0xffffffff8012d601 &amp;lt;sys_write+17&amp;gt;:      mov    %rbx0x18&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0xffffffff8012d606 &amp;lt;sys_write+22&amp;gt;:      mov    %rbp0x20&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;s2&quot;&gt;&amp;quot;rbp的内容由操作数0xfffffffffffffff7而来，跟对应栈上的内容一致&amp;quot;&lt;/span&gt;
0xffffffff8012d60b &amp;lt;sys_write+27&amp;gt;:      mov    &lt;span class=&quot;nv&quot;&gt;$0xfffffffffffffff7&lt;/span&gt;%rbp	//-EBADF
0xffffffff8012d612 &amp;lt;sys_write+34&amp;gt;:      mov    %r120x28&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0xffffffff8012d617 &amp;lt;sys_write+39&amp;gt;:      mov    %rdx%r12
0xffffffff8012d61a &amp;lt;sys_write+42&amp;gt;:      callq  0xffffffff8012e290 &amp;lt;fget_light&amp;gt;
0xffffffff8012d61f &amp;lt;sys_write+47&amp;gt;:      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;   %rax%rax
0xffffffff8012d622 &amp;lt;sys_write+50&amp;gt;:      mov    %rax%rbx
0xffffffff8012d625 &amp;lt;sys_write+53&amp;gt;:      je     0xffffffff8012d657 &amp;lt;sys_write+103&amp;gt;
0xffffffff8012d627 &amp;lt;sys_write+55&amp;gt;:      mov    0x48&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rax&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;%rax
0xffffffff8012d62b &amp;lt;sys_write+59&amp;gt;:      lea    0x8&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;%rcx

&lt;span class=&quot;s2&quot;&gt;&amp;quot;在调用vfs_write前，以下几条执令分别将rbx r12 r13赋值给rdi，rdx，rsi。&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt; 而这几个寄存器的含义正是被调用函数的入参。&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt; 根据vfs_write的定义vfs_write(struct file *file const char __user *buf size_t count loff_t *pos)&amp;quot;&lt;/span&gt;
0xffffffff8012d630 &amp;lt;sys_write+64&amp;gt;:      mov    %rbx%rdi	&lt;span class=&quot;s2&quot;&gt;&amp;quot;rdi是入参1 - file&amp;quot;&lt;/span&gt;
0xffffffff8012d633 &amp;lt;sys_write+67&amp;gt;:      mov    %r12%rdx	&lt;span class=&quot;s2&quot;&gt;&amp;quot;rdx是入参3 - count&amp;quot;&lt;/span&gt;
0xffffffff8012d636 &amp;lt;sys_write+70&amp;gt;:      mov    %r13%rsi	&lt;span class=&quot;s2&quot;&gt;&amp;quot;rsi是入参2 - buf&amp;quot;&lt;/span&gt;
0xffffffff8012d639 &amp;lt;sys_write+73&amp;gt;:      mov    %rax0x8&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0xffffffff8012d63e &amp;lt;sys_write+78&amp;gt;:      callq  0xffffffff8012d400 &amp;lt;vfs_write&amp;gt;
0xffffffff8012d643 &amp;lt;sys_write+83&amp;gt;:      mov    %rax%rbp	&lt;span class=&quot;s2&quot;&gt;&amp;quot;sys_write调用完后返回的第一条指令0xffffffff8012d643&amp;quot;&lt;/span&gt;
0xffffffff8012d646 &amp;lt;sys_write+86&amp;gt;:      mov    0x8&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rsp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;%rax&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据上面分析，可以清楚知道了栈上这几个数据的含义。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#8 [ffff8801b283df10] vfs_write at ffffffff8012d4ce&lt;/span&gt;
    ffff8801b283df18: ffff8801b518a080 ffff8801b7a5c5c0 &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;lt;- file&amp;quot;&lt;/span&gt;
    ffff8801b283df28: fffffffffffffff7 &lt;span class=&quot;m&quot;&gt;0000000000000002&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;lt;- count&amp;quot;&lt;/span&gt;
    ffff8801b283df38: 00007fe37c646000 &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;lt;- buf&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-3&quot;&gt;解题&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;回到问题，写哪个文件触发的crash。根据file对象，查到dentry里的name字段，推出是写sysrq-trigger文件触发的crash。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;crash&amp;gt; file ffff8801b7a5c5c0 &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; grep dentry
    &lt;span class=&quot;nv&quot;&gt;dentry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0xffff88008dbb2e90
crash&amp;gt; dentry 0xffff88008dbb2e90 &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; grep -E &lt;span class=&quot;s2&quot;&gt;&amp;quot;inode|name&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;d_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0xffff88008dbb2ec8 &lt;span class=&quot;s2&quot;&gt;&amp;quot;sysrq-trigger&amp;quot;&lt;/span&gt;	//文件名称
  &lt;span class=&quot;nv&quot;&gt;d_inode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0xffff8801b87b7898					//文件inode对象&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-4&quot;&gt;题外话&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;实际上找哪个文件触发的crash并不需要这么麻烦，根据bash进程的task_struct可以查到进程打开的所有文件的。直接使用files命令就可以方便的查到有sysrq-trigger。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;crash&amp;gt; files
PID: &lt;span class=&quot;m&quot;&gt;10109&lt;/span&gt;  TASK: ffff8801b80ee440  CPU: &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;   COMMAND: &lt;span class=&quot;s2&quot;&gt;&amp;quot;bash&amp;quot;&lt;/span&gt;
ROOT: /    CWD: /tmp/disk/tmp/
 FD       FILE            DENTRY           INODE       TYPE PATH
  &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; ffff8801b5321c80 ffff8800887e9e90 ffff8801b3a5c088 CHR  /dev/pts/2
  &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; ffff8801b7a5c5c0 ffff88008dbb2e90 ffff8801b87b7898 REG  &lt;span class=&quot;s2&quot;&gt;&amp;quot;/proc/sysrq-trigger&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; ffff8801b5321c80 ffff8800887e9e90 ffff8801b3a5c088 CHR  /dev/pts/2
 &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; ffff8801b5321c80 ffff8800887e9e90 ffff8801b3a5c088 CHR  /dev/pts/2
&lt;span class=&quot;m&quot;&gt;255&lt;/span&gt; ffff8801b5321c80 ffff8800887e9e90 ffff8801b3a5c088 CHR  /dev/pts/2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但，如果我们感兴趣的是执行过程中的某个变量，而crash工具没有提供简单命令查询，那还是要手动去解析，所以掌握这种分析方法仍然是非常有必要的。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;附：通用寄存器功能表&lt;/h1&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;system_call x86_64
/*
 * Register setup:
 * rax  system call number
 * rdi  arg0
 * rcx  return address for syscall/sysret C arg3
 * rsi  arg1
 * rdx  arg2
 * r10  arg3    (--&amp;gt; moved to rcx for C)
 * r8   arg4
 * r9   arg5
 * r11  eflags for syscall/sysret temporary for C
 * r12-r15rbprbx saved by C code not touched.
 *
 * Interrupts are off on entry.
 * Only called from user space.
 *
 * XXX  if we had a free scratch register we could save the RSP into the stack fr&amp;lt;x&amp;gt;ame
 *      and report it properly in ps. Unfortunately we haven&amp;#39;t.
 *
 * When user can change the fr&amp;lt;x&amp;gt;ames always force IRET. That is because
 * it deals with uncanonical addresses better. SYSRET has trouble
 * with them due to bugs in both AMD and Intel CPUs.
 */&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 19 Aug 2015 06:47:00 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/08/19/analysis-crash-stack.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/08/19/analysis-crash-stack.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>两张图了解linux IO子系统</title>
        <description>&lt;p&gt;来源:&lt;a href=&quot;http://www.ilinuxkernel.com/?p=1559&quot;&gt;www.ilinuxkernel.com&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;图1&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_io_stackv1.0.png&quot; alt=&quot;iostack&quot; title=&quot;iostack&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;图2&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/iostackv2.0.png&quot; alt=&quot;iostack2&quot; title=&quot;iostack2&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Aug 2015 07:54:32 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/08/17/iostack.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/08/17/iostack.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>常用的shell命令记录</title>
        <description>&lt;h2 id=&quot;find&quot;&gt;find命令&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;find / -name file		//根据name进行查找
find / -iname file		//无关大小写
find / -name &lt;span class=&quot;s2&quot;&gt;&amp;quot;*.sh&amp;quot;&lt;/span&gt;			//通配符，正则表达式
find / -name &lt;span class=&quot;s2&quot;&gt;&amp;quot;[A-Z]*&amp;quot;&lt;/span&gt;		//以A-Z为开头的文件

find / -size +5M				//根据size进行查找
find / -size -5M
find / -size +5M -a size -10M		//查找大于5M小于10M的文件, 条件and
find / -size +5M -o -name file	//大于5M，或名称是file，条件or

find / -atime -1				//查找1天没访问过的文件
find / -atime +30				//查找30内都天没访问过的文件
find / -amin -5 				//查找5分钟内访问过的文件
							//其它的还有ctime, mtime, cmin, mmin，
							//表示创建和修改时间，单位是天和分钟

find / -user root				//查找属主是root的文件

find / -type f 					//查找所有的文件 - &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;f 文件&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; d 目录&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; p 管道&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#find常与xargs配合使用&lt;/span&gt;
find / -size +100M &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; xargs rm	//查找大于100M的文件，并删除

&lt;span class=&quot;c&quot;&gt;#也后跟exec跟命令执行&lt;/span&gt;
find / -type f -exec mv &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt; tmp/ &lt;span class=&quot;se&quot;&gt;\;&lt;/span&gt;	//将匹配的文件移动到tmp目录&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;cut&quot;&gt;cut命令&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;cut -c -5 file			//取文件前5个字符
cut -c 5- file			//取文件第五个字符后的所有字符
cut -c 10-15 file		//取10-15个字符

cut -d &lt;span class=&quot;s2&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt; -f 1			//以&lt;span class=&quot;s2&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;为分割符，取field 1
cut -d : -f 1,3-5,7		//以:为分割符，取1，3-5，第7个字段&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;sed&quot;&gt;sed命令&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sed -i &lt;span class=&quot;s2&quot;&gt;&amp;quot;s/a/b/g&amp;quot;&lt;/span&gt; file	//将file中所有的a替换成b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;awk&quot;&gt;awk命令&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;1 2 3 4 5 &amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; awk &lt;span class=&quot;s1&quot;&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;	//取第一个字段&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 17 Aug 2015 04:54:00 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/08/17/shell-command.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/08/17/shell-command.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Markdown常用语法标记</title>
        <description>&lt;p&gt;本文的markdown标签针对ruby实现的kramdown解释器&lt;/p&gt;

&lt;h1 id=&quot;ruby&quot;&gt;ruby代码段&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;hello github.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &amp;#39;hello github.&amp;#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;c&quot;&gt;c代码段&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;shell&quot;&gt;shell片段&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;ls &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section&quot;&gt;标题示例&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;h1-&quot;&gt;H1 &lt;code&gt;#&lt;/code&gt;&lt;/h1&gt;

&lt;h2 id=&quot;h2-&quot;&gt;H2 &lt;code&gt;##&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&quot;h3-&quot;&gt;H3 &lt;code&gt;###&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&quot;h4-&quot;&gt;H4 &lt;code&gt;####&lt;/code&gt;&lt;/h4&gt;

&lt;h5 id=&quot;h5-&quot;&gt;H5 &lt;code&gt;#####&lt;/code&gt;&lt;/h5&gt;

&lt;h6 id=&quot;h6-&quot;&gt;H6 &lt;code&gt;######&lt;/code&gt;&lt;/h6&gt;

&lt;h1 id=&quot;section-1&quot;&gt;强调&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;强调1-1&lt;/em&gt; //用&lt;code&gt;*&lt;/code&gt;表示斜体&lt;/p&gt;

&lt;p&gt;&lt;em&gt;强调1-2&lt;/em&gt; //用&lt;code&gt;_&lt;/code&gt;也可以&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;强调2-1&lt;/strong&gt; //用&lt;code&gt;**&lt;/code&gt;表示粗体&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;强调2-2&lt;/strong&gt; //用&lt;code&gt;__&lt;/code&gt;也可以&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;强调3-1&lt;/em&gt;&lt;/strong&gt; //用&lt;code&gt;***&lt;/code&gt;表示斜粗体&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;强调3-2&lt;/em&gt;&lt;/strong&gt; //用&lt;code&gt;___&lt;/code&gt;也可以&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**这是什么&lt;/strong&gt;** //四个&lt;code&gt;*&lt;/code&gt;会被重新翻译，就不用了&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;列表&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;颜色&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;红&lt;/p&gt;

    &lt;p&gt;a. 朱红&lt;/p&gt;

    &lt;p&gt;b. 酒红&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;黄&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;深黄&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;淡黄&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-3&quot;&gt;引用&lt;/h1&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一段引用,用&lt;code&gt;&amp;gt;&lt;/code&gt;表示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-4&quot;&gt;字体颜色&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;em style=&quot;color:red&quot;&gt;红色&lt;/em&gt;. &lt;code&gt;*红色*{:style=&quot;color:red&quot;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em style=&quot;color:green&quot;&gt;绿色&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em style=&quot;color:yellow&quot;&gt;黄色&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;链接&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://www.google.com&quot;&gt;www.google.com&lt;/a&gt;  &lt;code&gt;[www.google.com](https://www.google.com)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;图片&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/images/github.png&quot; alt=&quot;github&quot; title=&quot;github&quot; /&gt;  &lt;code&gt;![github](/images/github.png &quot;github&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;表格&lt;/h1&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;head1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;head2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;head3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;b&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;c&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;sample2&quot;&gt;sample2&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Markdown&lt;/th&gt;
      &lt;th&gt;Less&lt;/th&gt;
      &lt;th&gt;Pretty&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;Still&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;renders&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;nicely&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 22 Jul 2015 15:30:00 +0800</pubDate>
        <link>http://zengxi0302.github.io/%E5%86%99%E4%BD%9C/2015/07/22/markdown-syntax.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/%E5%86%99%E4%BD%9C/2015/07/22/markdown-syntax.html</guid>
        
        
        <category>写作</category>
        
      </item>
    
      <item>
        <title>IO路径解析</title>
        <description>&lt;p&gt;首先，得看发出了哪些系统调用， strace出场&lt;/p&gt;

&lt;p&gt;我们关心的两个系统调用是open和write&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;open(&amp;quot;/mnt/sdb/zengxi/iopath/hello_file&amp;quot; O_WRONLY|O_CREAT 03777701360411750) = 3	//返回值是fd的值
write(3 &amp;quot;hello world!\n&amp;quot; 13)          = 13	//返回值是write系统调用写buf的长度&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，我们一起看看在内核里面做了什么事情&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;a.out(3594) close: args: 255
a.out(3594) vfs_read parms: file=0xffff880005edc2c0 buf=0xffff880052c4c800 count=0x188 pos=0xffff88005e6e9c68
a.out(3594) open: args: &amp;quot;/etc/ld.so.cache&amp;quot; O_RDONLY
a.out(3594) vfs_fstat parms: fd=0x3 stat=0xffff88005e6e9ef8
a.out(3594) vfs_getattr parms: mnt=0xffff8801b888e180 dentry=0xffff8800137e0a20 stat=0xffff88005e6e9ef8
a.out(3594) close: args: 3
a.out(3594) open: args: &amp;quot;/lib64/libc.so.6&amp;quot; O_RDONLY
a.out(3594) read: args: 3 0x7ffcd5fa2b78 832
a.out(3594) vfs_read parms: file=0xffff8801b1c39bc0 buf=0x7ffcd5fa2b78 count=0x340 pos=0xffff88005e6e9f50
a.out(3594) vfs_fstat parms: fd=0x3 stat=0xffff88005e6e9ef8
a.out(3594) vfs_getattr parms: mnt=0xffff8801b888e180 dentry=0xffff8801b84ee3a0 stat=0xffff88005e6e9ef8
a.out(3594) close: args: 3
a.out(3594) open: args: &amp;quot;/mnt/sdb/zengxi/iopath/hello_file&amp;quot; O_WRONLY|O_CREAT 01777777777772576431770
a.out(3594) vfs_fstat parms: fd=0x1 stat=0xffff88005e6e9ef8
a.out(3594) vfs_getattr parms: mnt=0xffff8801b888e280 dentry=0xffff8801a8948250 stat=0xffff88005e6e9ef8
a.out(3594) write: args: 1 &amp;quot;the address of msg: 0x7ffcd5fa32f0 sizeof ms&amp;quot;... 51
a.out(3594) vfs_write parms: file=0xffff8801b5733580 buf=0x7f9ad453f000 count=0x33 pos=0xffff88005e6e9f50
a.out(3594) vfs_fstat parms: fd=0x0 stat=0xffff88005e6e9ef8
a.out(3594) vfs_getattr parms: mnt=0xffff8801b888e280 dentry=0xffff8801a8948250 stat=0xffff88005e6e9ef8
a.out(3594) read: args: 0 0x7f9ad453e000 1024
a.out(3594) vfs_read parms: file=0xffff8801b5733580 buf=0x7f9ad453e000 count=0x400 pos=0xffff88005e6e9f50&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;hello world已经被写入到Page Cache当中&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;============================================================================================================================================
vfs_write
	generic_file_aio_write
		generic_file_direct_write	//direct写
		generic_file_buffered_write	//buffer写
			generic_perform_write
				write_begin (address_space_operations-&amp;gt;write_begin) //依据具体的文件系统定义的write_begin和write_end
					iov_iter_copy_from_user_atomic //从用户空间将buf拷贝到内核空间，相当于进入page cache					
				write_end (address_space_operations-&amp;gt;write_end)
				
			ext2/ext3/ext4
	File.c (fs\ext2):	.aio_write	= generic_file_aio_write
	File.c (fs\ext3):	.aio_write	= generic_file_aio_write
	File.c (fs\ext4):	.aio_write	= ext4_file_write
	
ocfs2
	File.c (fs\ocfs2):	.aio_write	= ocfs2_file_aio_write
============================================================================================================================================&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;fluser进程刷写脏页&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;============================================================================================================================================
bdi_forker_thread
	task = kthread_create(bdi_writeback_thread &amp;amp;bdi-&amp;gt;wb &amp;quot;flush-%s&amp;quot; dev_name(bdi-&amp;gt;dev)); //backing-dev.c，创建针对块设备的flush进程

bdi_writeback_thread
	wb_do_writeback
		wb_writeback
			__writeback_inodes_sb //if （work-&amp;gt;sb）
			writeback_inodes_wb
				wb_inode 		//获取要回写的inode
				writeback_sb_inodes	//回写属于这个superblock的所有inode
					writeback_single_inode	//分解写单个inode
						do_writepages
							mapping-&amp;gt;a_ops-&amp;gt;writepages	//如果文件系统自定义了writepages的方法，调用之
							generic_writepages		//否则，使用通用的writepages方法
								__writepage
									mapping-&amp;gt;a_ops-&amp;gt;writepage	//调用文件系统自定义的写单个页面的方法，必需实现
============================================================================================================================================&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;回到具体文件系统中，将page内容封装成块层需要的buffer_head和bio，向下提交&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ext2/ext3/ext4
	Inode.c (fs\ext2):	.writepage		= ext2_writepage
	Inode.c (fs\ext3):	.writepage		= ext3_writeback_writepage
	Inode.c (fs\ext4):	.writepage		= ext4_writepage	
ocfs2
	Aops.c (fs\ocfs2):	.writepage		= ocfs2_writepage
============================================================================================================================================
ext3_writeback_writepage
	block_write_full_page	//提交整个page
		block_write_full_page_endio //并注册io完成的回调函数是end_buffer_async_write
			__block_write_full_page
				mark_buffer_async_write_endio		//将page中所有的buffer_head的设置io返回回调函数（因为一个page当中可能包含多个io，每个io都需要设置end_io函数）
				submit_bh				//遍历page中的所有buffer_head，调用submit_bh提交
					_submit_bh			
						submit_bio		//提交到块层
============================================================================================================================================&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;经submit_bio后，io进入到块层
进入块层之后，文件的概念就彻底消失了，只有块，准确的说是扇区。
为什么要设置块层，主要的目的是 – IO调度 (noop deadline cfq)所在的位置&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;============================================================================================================================================
submit_bio
	generic_make_request	//将io请求封装成request
		__generic_make_request
			q = bdev_get_queue(bio-&amp;gt;bi_bdev);	//获取到这个设备的请求队列(request_queue)
			ret = q-&amp;gt;make_request_fn(q bio);	//调用make_request_fn出队列
============================================================================================================================================&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 19 Jul 2015 08:04:10 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/07/19/iopath.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/07/19/iopath.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>xenstore操作方法</title>
        <description>&lt;p&gt;XenStore是Xen提供的一个域间共享的存储系统，它以字符串形式存放了管理程序和前（frontend）、后端驱动程序(backend)的配置信息。
Dom0管理所有的数据，而DomU通过共享内存，向Dom0请求与自己相关的键值，以此实现域间通信。
Xen提供了多种接口用来操作XenStore：命令行的xenstore命令、用户空间的xs系列函数、内核的XenBus接口，都可以用来方便地操作XenStore的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/xenstore_operation.png&quot; alt=&quot;xenstore&quot; title=&quot;xenstore operations&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Jul 2015 07:20:00 +0800</pubDate>
        <link>http://zengxi0302.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96/2015/07/18/xenstore.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96/2015/07/18/xenstore.html</guid>
        
        
        <category>虚拟化</category>
        
      </item>
    
      <item>
        <title>用户态和内核态Makefile简单模板</title>
        <description>&lt;p&gt;用户态Makefile&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SRCS = $(wildcard *.c)
OBJS = $(SRCS:.c = .o)
CC = gcc
INCLUDES = -I/usr/include
LIBS = -L/usr/lib -lpthread
CCFLAGS = -g -Wall -O0
main : $(OBJS)
        $(CC) $^ -o $@ $(INCLUDES) $(LIBS) 
%.o : %.c
        $(CC) -c {1}lt;; $(CCFLAGS) 
clean:
        -rm *.o
        -rm main&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;内核态Makefile&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;obj-m := delay_workqueue.o

PWD = $(shell pwd)
KERNELDIR = /lib/modules/$(shell uname -r)/build

default: 
    $(MAKE) -C $(KERNELDIR) M=$(PWD) modules&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 17 Jul 2015 08:18:32 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/07/17/makefile.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/07/17/makefile.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>在ubuntu14.04下安装systemtap</title>
        <description>&lt;h3 id=&quot;debuginfo&quot;&gt;&lt;em&gt;获取对应内核版本的debuginfo安装包&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;首先，查询所用系统的内核版本&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;zengxi&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@zengxi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ubuntu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/$ uname -r&lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;3.13.0-24-generic&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本人机器是ubuntu14.04，可到一下网址获取debuginfo包&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-3.13.0-24-generic-dbgsym_3.13.0-24.46_i386.ddeb&quot;&gt;http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-3.13.0-24-generic-dbgsym_3.13.0-24.46_i386.ddeb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后，使用&lt;code&gt;dpkg -i linux-image-3.13.0-24-generic-dbgsym_3.13.0-24.46_i386.ddeb&lt;/code&gt;安装&lt;/p&gt;

&lt;p&gt;安装完后确认/usr/lib/debug目录下有安装的文件。&lt;/p&gt;

&lt;h3 id=&quot;systemtap&quot;&gt;&lt;em&gt;安装systemtap&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install systemtap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用命令测试一下是不是安装成功&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stap -ve &#39;probe begin { log(&quot;hello world&quot;) exit () }&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体systemtap的原理和介绍可参考这篇文档&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html&quot;&gt;http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 17 Jul 2015 07:54:32 +0800</pubDate>
        <link>http://zengxi0302.github.io/linux/2015/07/17/systemtap-on-ubuntu14.04.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/linux/2015/07/17/systemtap-on-ubuntu14.04.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>this is a test</title>
        <description>&lt;p&gt;这是第一篇测试文章 - &lt;code&gt;test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/lufei.png&quot; alt=&quot;lufei&quot; title=&quot;katong lufei&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;hello github.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &amp;#39;hello github.&amp;#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 16 Jul 2015 07:54:32 +0800</pubDate>
        <link>http://zengxi0302.github.io/test/2015/07/16/test.html</link>
        <guid isPermaLink="true">http://zengxi0302.github.io/test/2015/07/16/test.html</guid>
        
        
        <category>test</category>
        
      </item>
    
  </channel>
</rss>
